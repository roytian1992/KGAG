{
  "id": "entity_type_merge_prompt",
  "category": "regular_function",
  "name": "实体类型合并判断提示词（思维链版，单实体多类型）",
  "description": "用于在同一实体的多个候选实体类型之间，基于提供的上下文判断是否需要进行合并，并给出合并映射；若不需要合并则返回空数组。",
  "template": "你是一位知识图谱构建专家。任务：针对“同一实体”的多个候选实体类型，依据提供的上下文证据，判断是否需要将某些类型合并为另一类型。请在内部进行严谨的思维链推理，但最终输出中不得暴露推理过程，只输出 JSON 结果。\n\n【输入】\n{context}\n\n【思维链步骤（仅内在推理，不要输出）】\n1. 提取候选类型集合，以及每个类型在上下文中的证据（定义/出现片段/角色/约束）。\n2. 逐对比对类型关系：语义等价 / 上下位（A⊂B 或 B⊂A）/ 不同语义维度（可并存）。\n3. 合并准则：\n   - 语义等价：在该实体语境下表达同一类别，合并为更稳定、更具体的目标类型。\n   - 语义收紧：存在上/下位关系且上下文明确收紧到下位类型，并且上位类型不再提供独立信息价值，则将上位并入下位。\n   - 标签冗余/同义别名：不同命名但在项目规范中等价，合并为规范类型名。\n   - 常见特例：若候选集中同时出现“Concept”与某个更具体类型（如 Character/Object/Location/Event/Action 等），且上下文已将实体具体化，则将“Concept”合并到该具体类型。\n4. 不合并条款：\n   - 不同语义维度可并存（如 Location 与 Object 同时成立且各有证据）。\n   - 抽象层次不同但上下文需要保留（通用类别与实例化角色均提供信息价值）。\n   - 证据不足或存在冲突时不合并。\n5. 目标类型选择：优先选择更具体、更贴合上下文、信息量更大且更稳定的类型作为合并目标；不得创建新类型，只能在候选集中选择。\n6. 一致性检查：去重；禁止自映射（from==to）与环（A→B 且 B→A）；仅使用输入中出现过的类型名。\n\n【输出格式（严格遵循）】\n请仅以如下 JSON 返回结果：\n\n```json\n{{\n  \"filtering_rules\": [\n    {{ \"type1\": \"type2\" }},\n    {{ \"type3\": \"type2\" }}\n  ]\n}}\n```\n表示把 type1 合并到 type2，type3 也合并到 type2。\n\n如完全不合并，则返回：\n\n```json\n{\n  \"filtering_rules\": []\n}\n```\n\n【严格要求】\n- 只输出上述 JSON 对象，不要输出解释或多余字段。\n- 字段名保持一致：filtering_rules。\n- 确保合法 JSON，可被直接解析。\n- 仅使用输入中出现过的类型名称，不创建新类型。",
  "variables": [
    {
      "name": "context",
      "description": "同一实体的候选类型与证据上下文（类型列表、定义/规范、出现语境片段、任务域规则等）"
    }
  ]
}
